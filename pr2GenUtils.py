import random
import hu
from planUtil import ObjGraspB
from traceFile import tr, debug, debugMsg
from miscUtil import roundrobin
from pr2Util import PoseD

def fixed(value):
    return value and isinstance(value, tuple) and len(value) == 2 and value[0]

def sortedHyps(hypGen, validTestFn, costFn, maxHyps, maxTries,
              minCost = 0., size = 10):
    costHistory = []
    hypHistory = []
    historySize = min(size, maxHyps)    # used to be 5 or 20
    tries = 0
    count = 0
    while count < maxHyps and tries < maxTries:
        tries += 1
        hyp = next(hypGen, None)
        if hyp and validTestFn(hyp):
            cost = costFn(hyp)
        elif len(costHistory) > 0:
            # return some previous hyp
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            del costHistory[minIndex]
            del hypHistory[minIndex]
            count += 1
            yield hyp
            continue
        else:
            return
        assert hyp                      # we have a hyp and it's valid
        if cost == minCost:             # best possible, so yield it
            hypCost = cost
        elif len(costHistory) < historySize:
            # build up the history
            costHistory.append(cost)
            hypHistory.append(hyp)
            continue
        elif cost > min(costHistory):
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            costHistory[minIndex] = cost
            hypHistory[minIndex] = hyp
        else:                           # cost <= min(costHistory)
            hypCost = cost
        count += 1
        yield hyp

def baseDist(c1, c2):
    (x1,y1,th1) = c1['pr2Base']
    (x2,y2,th2) = c2['pr2Base']
    return ((x2-x1)**2 + (y2-y1)**2 + hu.angleDiff(th1,th2)**2)**0.5


# Our choices are (generated by graspGen):
# 1. The grasp surface (graspDesc)
# !! 2. The pose on the grasp surface (3 params) -- for now -- skip this
# 3. The conf of the robot (and an approach conf, but we won't vary that)
def graspGen(pbs, graspB, placeB=None, conf=None, hand=None, prob=None):
    obj = graspB.obj
    grasps = list(graspB.grasp.support())
    random.shuffle(grasps)
    for grasp in grasps:
        if debug('graspGen'):
            print 'graspGen: Generating grasp=', grasp
        # TODO: Should also sample a pose in the grasp face...
        gB = ObjGraspB(graspB.obj, graspB.graspDesc, grasp, None,
                       # !! Need to pick offset for grasp to be feasible
                       PoseD(graspB.poseD.mode() or hu.Pose(0.0, -0.025, 0.0, 0.0),
                             graspB.poseD.var),
                       delta=graspB.delta)
        yield gB

###### Helpers for XinGen

def getRegions(region):
    if not isinstance(region, (list, tuple, frozenset)):
        return frozenset([region])
    elif len(region) == 0:
        raise Exception, 'need a region to place into'
    else:
        return frozenset(region)

def getPoseAndSupport(tag, obj, pbs, prob):
    # Set pose and support from current state
    pose = None
    if pbs.getPlaceB(obj, default=False):
        # If it is currently placed, use that support
        support = pbs.getPlaceB(obj).support.mode()
        pose = pbs.getPlaceB(obj).poseD.mode()
        tr(tag, 'Using current placeB, support=%s, pose=%s'%(support, pose.xyztTuple()))
    elif obj == pbs.getHeld('left'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'left')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('left', support))
    elif obj == pbs.getHeld('right'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'right')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('right', support))
    else:
        raise Exception('Cannot determine support')
    return pose, support

    
#############

def confDelta(c1, c2):
    return max([max([abs(x-y) for (x,y) in zip(c1.conf[k], c2.conf[k])]) \
                for k in c1 if k in c2])

def findGraspConfEntries(conf):
    return [(c, ca, pbs, prob, viol) \
            for (c, ca, pbs, prob, viol) in graspConfs \
            if confDelta(c, conf) < 0.001 or confDelta(ca, conf) < 0.001]


def chooseHandGen(pbs, cpbs, obj, hand, leftGen, rightGen):
    tag = 'chooseHandGen'
    assert not (pbs.useRight == False and hand == 'right')
    mustUseLeft = (hand == 'left' or not pbs.useRight)
    mustUseRight = (hand == 'right')

    # What are we required to be holding
    leftHeldInGoal = fixed(cpbs.held['left'])
    rightHeldInGoal = fixed(cpbs.held['right'])

    # What are we currently holding (heuristic value)
    leftHeldNow = pbs.getHeld('left') != 'none'
    rightHeldNow = pbs.getHeld('right') != 'none'

    # Are we already holding the desired object
    leftHeldTargetObjNow = pbs.getHeld('left') == obj
    rightHeldTargetObjNow = pbs.getHeld('right') == obj

    if leftHeldInGoal and rightHeldInGoal:
        # Both hands are busy!!
        return []

    if mustUseLeft or rightHeldInGoal:
        if leftHeldInGoal:
            tr(tag, 0, '=> Left held already in goal, fail')
            return []
        else:
            gen = leftGen
    elif mustUseRight or leftHeldInGoal:
        if rightHeldInGoal:
            tr(tag, 0, '=> Right held already in goal, fail')
            return []
        else:
            gen = rightGen
    elif rightHeldTargetObjNow or (leftHeldNow and not leftHeldTargetObjNow):
        # Try right hand first if we're holding something in the left
        gen = roundrobin(rightGen, leftGen)
    elif leftHeldTargetObjNow or (rightHeldNow and not rightHeldTargetObjNow):
        # Try right hand first if we're holding something in the left
        gen = roundrobin(leftGen, rightGen)
    else:
        gen = roundrobin(rightGen, leftGen)
    return gen

def minimalConf(conf, hand):
    if hand == 'left':
        return (tuple(conf['pr2Base']), tuple(conf['pr2LeftArm']))
    else:
        return (tuple(conf['pr2Base']), tuple(conf['pr2RightArm']))

################
## Drawing
################
    
def drawPoseConf(pbs, placeB, conf, confAppr, prob, win, color = None):
    ws = pbs.getShadowWorld(prob)
    ws.world.getObjectShapeAtOrigin(placeB.obj).applyLoc(placeB.objFrame()).draw(win, color=color)
    conf.draw(win, color=color)

def drawObjAndShadow(pbs, placeB, prob, win, color = None):
    # Draw the object in its native color, but use the argument for the shadow
    ws = pbs.getShadowWorld(prob)
    obj = placeB.obj
    ws.world.getObjectShapeAtOrigin(obj).applyLoc(placeB.objFrame()).draw(win)
    if shadowName(obj) in ws.world.objects:
        ws.world.getObjectShapeAtOrigin(shadowName(obj)).applyLoc(placeB.objFrame()).draw(win, color=color)

def sameBase(pbs):
    # base is None or (fixed, base)
    return pbs.base and pbs.base[0]     # fixed base
