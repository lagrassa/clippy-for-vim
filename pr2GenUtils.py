import pdb
import random
import hu
from planUtil import ObjGraspB
from traceFile import tr, debug, debugMsg
from miscUtil import roundrobin
from pr2Util import PoseD, supportFaceIndex
import planGlobals as glob
from gjk import gjkDist

def fixed(value):
    return value and isinstance(value, tuple) and len(value) == 2 and value[0]

def sortedHyps(hypGen, validTestFn, costFn, maxHyps, maxTries,
              minCost = 0., size = 1 if glob.inHeuristic else 3):
    tag = 'sortedHyps'
    costHistory = []
    hypHistory = []
    historySize = min(size, maxHyps)    # used to be 5 or 20
    tries = 0
    count = 0
    while count < maxHyps and tries < maxTries:
        if debug(tag):
            print 'sortedHyps, count=', count, 'tries=', tries, 'history=', len(costHistory)
        tries += 1
        hyp = next(hypGen, None)
        if debug(tag): print 'hyp', hyp
        if hyp is None and len(costHistory) == 0:
            return
        # if debug(tag): pdb.set_trace()
        if hyp and validTestFn(hyp):
            cost = costFn(hyp)
            if debug(tag): print 'hyp cost', cost, 'hyp', hyp
        elif len(costHistory) > 0:
            # return some previous hyp
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            del costHistory[minIndex]
            del hypHistory[minIndex]
            count += 1
            if debug(tag): print 'yield earlier hyp', hyp, 'with cost', hypCost
            yield hyp
            continue
        else:
            if debug(tag): print 'try another hyp'
            continue                    # keep trying
        assert hyp                      # we have a hyp and it's valid
        if cost == minCost:             # best possible, so yield it
            if debug(tag): print 'yield min hyp cost', cost
        elif len(costHistory) < historySize:
            # build up the history
            costHistory.append(cost)
            hypHistory.append(hyp)
            if debug(tag): print 'save hyp and keep looking'
            continue
        elif cost > min(costHistory):
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            costHistory[minIndex] = cost
            hypHistory[minIndex] = hyp
            if debug(tag): print 'yield best hyp so far', hyp, 'with cost ', hypCost
        else:                           # cost <= min(costHistory)
            if debug(tag): print 'yield hyp with cost', cost
        count += 1
        if debug(tag):
            raw_input(hyp)
        yield hyp

def baseDist(c1, c2):
    (x1,y1,th1) = c1.baseConf()
    (x2,y2,th2) = c2.baseConf()
    return ((x2-x1)**2 + (y2-y1)**2 + (0.33*hu.angleDiff(th1,th2))**2)**0.5

def inflatedBS(pbs, prob, sd=0.05):
    newBS = pbs.copy()
    for obj in newBS.objectBs:
        fix, objB = newBS.objectBs[obj]
        inflatedVar = (sd**2, sd**2, sd**2, (2*sd)**2)
        newBS.updatePlaceB(objB.modifyPoseD(var=inflatedVar))
    return newBS


def collisionMargin(pbs, prob, conf):
    shWorld = pbs.getShadowWorld(prob)
    placeParts = [x for x in conf.placement().parts() if 'Gripper' not in x.name()]
    placePrims = []
    for p in placeParts: placePrims.extend(p.toPrims())
    minDist = float('inf')
    minPair = None
    dists = []
    for shape in shWorld.getNonShadowShapes():
        for sp in shape.toPrims():
            for pp in placePrims:
                dist = gjkDist(sp, pp)**0.5
                dists.append((dist, (pp, sp)))
    minDists = sorted(dists)[:5]

    if debug('collisionWeight'):
        colors = ['red', 'green', 'blue', 'magenta', 'cyan']
        pbs.draw(prob, 'W'); conf.draw('W')
        for ((d, (pp, sp)), color) in zip(minDists, colors):
            print 'minDist', d, 'minPair', (pp.name(), sp.name())
            pp.draw('W', color); sp.draw('W', color)
            raw_input('Ok?')
    
    minDists = [x[0] for x in minDists]
    return sum(minDists)/len(minDists)

def feasiblePBS(pB, pbs, pause=False):
    if pbs.conditions:
        print '*** Testing feasibibility with %d conditions'%(len(pbs.conditions))
        for c in pbs.conditions:
            print c
        pbsCopy = pbs.copy()
        pbsCopy.updatePermObjBel(pB)
        feasible = pbsCopy.feasible()   # check conditioned fluents
        print '*** feasible =>', feasible
        if not glob.inHeuristic and pause: pdb.set_trace()
        return feasible
    else:
        return True


# Our choices are (generated by graspGen):
# 1. The grasp surface (graspDesc)
# !! 2. The pose on the grasp surface (3 params) -- for now -- skip this
# 3. The conf of the robot (and an approach conf, but we won't vary that)
def graspGen(pbs, graspB, placeB=None, conf=None, hand=None, prob=None):
    obj = graspB.obj
    grasps = list(graspB.grasp.support())
    random.shuffle(grasps)
    inHand = hand and obj == pbs.getHeld(hand)
    if inHand:
        # Put current grasp first if it's elegible
        gB = pbs.getGraspB(hand)
        currGrasp = gB.grasp.mode()
        if currGrasp in grasps:
            grasps = [currGrasp] + [g for g in grasps if g != currGrasp]
    for grasp in grasps:
        if debug('graspGen'):
            print 'graspGen: Generating grasp=', grasp
        # TODO: Should also sample a pose in the grasp face...
        gB = ObjGraspB(graspB.obj, graspB.graspDesc, grasp, None,
                       # !! Need to pick offset for grasp to be feasible
                       PoseD(graspB.poseD.mode() or hu.Pose(0.0, -0.025, 0.0, 0.0),
                             graspB.poseD.var),
                       delta=graspB.delta)
        yield gB

def currentGrasp(pbs, gB, hand):
    if gB.obj == pbs.getHeld(hand):
        currGraspB = pbs.getGraspB(hand)
        return  (gB.grasp.mode() == currGraspB.grasp.mode()) and \
               gB.poseD.mode().near(currGraspB.poseD.mode(), .01, .01)
    return False

###### Helpers for XinGen

def getRegions(region):
    if not isinstance(region, (list, tuple, frozenset)):
        return frozenset([region])
    elif len(region) == 0:
        raise Exception, 'need a region to place into'
    else:
        return frozenset(region)

def getPoseAndSupport(tag, obj, pbs, prob):
    # Set pose and support from current state
    pose = None
    if pbs.getPlaceB(obj, default=False):
        # If it is currently placed, use that support
        support = pbs.getPlaceB(obj).support.mode()
        pose = pbs.getPlaceB(obj).poseD.mode()
        tr(tag, 'Using current placeB, support=%s, pose=%s'%(support, pose.xyztTuple()))
    elif obj == pbs.getHeld('left'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'left')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('left', support))
    elif obj == pbs.getHeld('right'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'right')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('right', support))
    else:
        raise Exception('Cannot determine support')
    return pose, support

    
#############

def confDelta(c1, c2):
    return max([max([abs(x-y) for (x,y) in zip(c1.conf[k], c2.conf[k])]) \
                for k in c1 if k in c2])

def findGraspConfEntries(conf):
    return [(c, ca, pbs, prob, viol) \
            for (c, ca, pbs, prob, viol) in graspConfs \
            if confDelta(c, conf) < 0.001 or confDelta(ca, conf) < 0.001]


# For action==place, pre-condition is Holding(hand) = obj
# For action==push, pre-condition is Holding(hand) = 'none'
# 1. Reject bindings for hand that would make the pre-condition inconsistent with the goal.
# 2. Prefer bindings that would make the pre-condition "closer" to
# current state, e.g. if a hand is empty it is a better candidate than
# if it is full with a different object.

def chooseHandGen(action, pbs, cpbs, obj, hand, leftGen, rightGen):
    tag = 'chooseHandGen'
    assert action in ('place', 'push')
    assert not (pbs.useRight == False and hand == 'right')
    mustUseLeft = (hand == 'left' or not pbs.useRight)
    mustUseRight = (hand == 'right')
    # Are we already holding the desired object?
    leftHeldTargetObjNow = pbs.getHeld('left') == obj
    rightHeldTargetObjNow = pbs.getHeld('right') == obj
    # Are we currently holding something?
    leftHeldNow = pbs.getHeld('left') != 'none'
    rightHeldNow = pbs.getHeld('right') != 'none'
    # For pushing, Holding(hand)='none' is equiv to unspecified
    if action == 'place':
        # What are we required to be holding (including 'none')?
        leftHeldInGoal = fixed(cpbs.held['left'])
        rightHeldInGoal = fixed(cpbs.held['right'])
    elif action == 'push':
        # What are we required to be holding (not including 'none')?
        leftHeldInGoal = fixed(cpbs.held['left']) and cpbs.getHeld('left') != 'none'
        rightHeldInGoal = fixed(cpbs.held['right']) and cpbs.getHeld('right') != 'none'
    if leftHeldInGoal and rightHeldInGoal:
        # Cannot be Holding(hand)=obj in goal, so it must be Holding(hand)=other
        # Adding Holding(hand)=obj for either hand will be inconsistent
        tr(tag, '=> Both hands already held in goal, fail')
        return []
    if mustUseLeft or rightHeldInGoal:
        # Left hand is only choice
        if leftHeldInGoal:
            tr(tag, '=> Must use left but left held already in goal, fail')
            return []
        else:
            gen = leftGen
    elif mustUseRight or leftHeldInGoal:
        # Right hand is only choice
        if rightHeldInGoal:
            tr(tag, '=> Must use right but right held already in goal, fail')
            return []
        else:
            gen = rightGen
    elif rightHeldTargetObjNow or (leftHeldNow and not leftHeldTargetObjNow):
        # Try right hand first if we're holding something else in the left or the target in the right.
        gen = roundrobin(rightGen, leftGen)
    elif leftHeldTargetObjNow or (rightHeldNow and not rightHeldTargetObjNow):
        # Try left hand first if we're holding something else in the right or the target in the left
        gen = roundrobin(leftGen, rightGen)
    else:
        # Just prefer right hand
        gen = roundrobin(rightGen, leftGen)

    return gen

################
## Drawing
################
    
def drawPoseConf(pbs, placeB, conf, confAppr, prob, win, color = None):
    ws = pbs.getShadowWorld(prob)
    ws.world.getObjectShapeAtOrigin(placeB.obj).applyLoc(placeB.objFrame()).draw(win, color=color)
    conf.draw(win, color=color)

def drawObjAndShadow(pbs, placeB, prob, win, color = None):
    # Draw the object in its native color, but use the argument for the shadow
    ws = pbs.getShadowWorld(prob)
    obj = placeB.obj
    ws.world.getObjectShapeAtOrigin(obj).applyLoc(placeB.objFrame()).draw(win)
    if shadowName(obj) in ws.world.objects:
        ws.world.getObjectShapeAtOrigin(shadowName(obj)).applyLoc(placeB.objFrame()).draw(win, color=color)

def sameBase(pbs):
    # base is None or (fixed, base)
    return pbs.base and pbs.base[0]     # fixed base
