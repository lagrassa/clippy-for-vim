import random
import hu
from planUtil import ObjGraspB
from traceFile import tr, debug, debugMsg
from miscUtil import roundrobin
from pr2Util import PoseD, supportFaceIndex

def fixed(value):
    return value and isinstance(value, tuple) and len(value) == 2 and value[0]

def sortedHyps(hypGen, validTestFn, costFn, maxHyps, maxTries,
              minCost = 0., size = 10):
    tag = 'sortedHyps'
    costHistory = []
    hypHistory = []
    historySize = min(size, maxHyps)    # used to be 5 or 20
    tries = 0
    count = 0
    while count < maxHyps and tries < maxTries:
        tries += 1
        hyp = next(hypGen, None)
        if debug(tag): print 'hyp', hyp
        if hyp and validTestFn(hyp):
            cost = costFn(hyp)
            if debug(tag): print 'hyp cost', cost
        elif len(costHistory) > 0:
            # return some previous hyp
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            del costHistory[minIndex]
            del hypHistory[minIndex]
            count += 1
            if debug(tag): print 'yield hyp', hyp, 'with cost', hypCost
            yield hyp
            continue
        else:
            continue                    # keep trying
        assert hyp                      # we have a hyp and it's valid
        if cost == minCost:             # best possible, so yield it
            hypCost = cost
            if debug(tag): print 'yield min hyp cost', hypCost
        elif len(costHistory) < historySize:
            # build up the history
            costHistory.append(cost)
            hypHistory.append(hyp)
            if debug(tag): print 'save hyp and keep looking'
            continue
        elif cost > min(costHistory):
            minIndex = costHistory.index(min(costHistory))
            hyp = hypHistory[minIndex]
            hypCost = costHistory[minIndex]
            costHistory[minIndex] = cost
            hypHistory[minIndex] = hyp
            if debug(tag): print 'yield best hyp so far', hyp, 'with cost ', hypCost
        else:                           # cost <= min(costHistory)
            if debug(tag): print 'yield hyp with cost', hypCost
            hypCost = cost
        count += 1
        yield hyp

def baseDist(c1, c2):
    (x1,y1,th1) = c1['pr2Base']
    (x2,y2,th2) = c2['pr2Base']
    return ((x2-x1)**2 + (y2-y1)**2 + hu.angleDiff(th1,th2)**2)**0.5


# Our choices are (generated by graspGen):
# 1. The grasp surface (graspDesc)
# !! 2. The pose on the grasp surface (3 params) -- for now -- skip this
# 3. The conf of the robot (and an approach conf, but we won't vary that)
def graspGen(pbs, graspB, placeB=None, conf=None, hand=None, prob=None):
    obj = graspB.obj
    grasps = list(graspB.grasp.support())
    random.shuffle(grasps)
    inHand = hand and obj == pbs.getHeld(hand)
    if inHand:
        # Put current grasp first
        gB = pbs.getGraspB(hand)
        currGrasp = gB.grasp.mode()
        grasps = [currGrasp] + [g for g in grasps if g != currGrasp]
    for grasp in grasps:
        if debug('graspGen'):
            print 'graspGen: Generating grasp=', grasp
        # TODO: Should also sample a pose in the grasp face...
        gB = ObjGraspB(graspB.obj, graspB.graspDesc, grasp, None,
                       # !! Need to pick offset for grasp to be feasible
                       PoseD(graspB.poseD.mode() or hu.Pose(0.0, -0.025, 0.0, 0.0),
                             graspB.poseD.var),
                       delta=graspB.delta)
        yield gB

def currentGrasp(pbs, gB, hand):
    if gB.obj == pbs.getHeld(hand):
        currGraspB = pbs.getGraspB(hand)
        return  (gB.grasp.mode() == currGraspB.grasp.mode()) and \
               gB.poseD.mode().near(currGraspB.poseD.mode(), .01, .01)
    return False

###### Helpers for XinGen

def getRegions(region):
    if not isinstance(region, (list, tuple, frozenset)):
        return frozenset([region])
    elif len(region) == 0:
        raise Exception, 'need a region to place into'
    else:
        return frozenset(region)

def getPoseAndSupport(tag, obj, pbs, prob):
    # Set pose and support from current state
    pose = None
    if pbs.getPlaceB(obj, default=False):
        # If it is currently placed, use that support
        support = pbs.getPlaceB(obj).support.mode()
        pose = pbs.getPlaceB(obj).poseD.mode()
        tr(tag, 'Using current placeB, support=%s, pose=%s'%(support, pose.xyztTuple()))
    elif obj == pbs.getHeld('left'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'left')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('left', support))
    elif obj == pbs.getHeld('right'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'right')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('right', support))
    else:
        raise Exception('Cannot determine support')
    return pose, support

    
#############

def confDelta(c1, c2):
    return max([max([abs(x-y) for (x,y) in zip(c1.conf[k], c2.conf[k])]) \
                for k in c1 if k in c2])

def findGraspConfEntries(conf):
    return [(c, ca, pbs, prob, viol) \
            for (c, ca, pbs, prob, viol) in graspConfs \
            if confDelta(c, conf) < 0.001 or confDelta(ca, conf) < 0.001]


# For action==place, pre-condition is Holding(hand) = obj
# For action==push, pre-condition is Holding(hand) = 'none'
# 1. Reject bindings for hand that would make the pre-condition inconsistent with the goal.
# 2. Prefer bindings that would make the pre-condition "closer" to
# current state, e.g. if a hand is empty it is a better candidate than
# if it is full with a different object.

def chooseHandGen(action, pbs, cpbs, obj, hand, leftGen, rightGen):
    tag = 'chooseHandGen'
    assert action in ('place', 'push')
    assert not (pbs.useRight == False and hand == 'right')
    mustUseLeft = (hand == 'left' or not pbs.useRight)
    mustUseRight = (hand == 'right')
    # Are we already holding the desired object?
    leftHeldTargetObjNow = pbs.getHeld('left') == obj
    rightHeldTargetObjNow = pbs.getHeld('right') == obj
    # Are we currently holding something?
    leftHeldNow = pbs.getHeld('left') != 'none'
    rightHeldNow = pbs.getHeld('right') != 'none'
    # For pushing, Holding(hand)='none' is equiv to unspecified
    if action == 'place':
        # What are we required to be holding (including 'none')?
        leftHeldInGoal = fixed(cpbs.held['left'])
        rightHeldInGoal = fixed(cpbs.held['right'])
    elif action == 'push':
        # What are we required to be holding (not including 'none')?
        leftHeldInGoal = fixed(cpbs.held['left']) and cpbs.getHeld('left') != 'none'
        rightHeldInGoal = fixed(cpbs.held['right']) and cpbs.getHeld('right') != 'none'
    if leftHeldInGoal and rightHeldInGoal:
        # Cannot be Holding(hand)=obj in goal, so it must be Holding(hand)=other
        # Adding Holding(hand)=obj for either hand will be inconsistent
        tr(tag, '=> Both hands already held in goal, fail')
        return []
    if mustUseLeft or rightHeldInGoal:
        # Left hand is only choice
        if leftHeldInGoal:
            tr(tag, '=> Must use left but left held already in goal, fail')
            return []
        else:
            gen = leftGen
    elif mustUseRight or leftHeldInGoal:
        # Right hand is only choice
        if rightHeldInGoal:
            tr(tag, '=> Must use right but right held already in goal, fail')
            return []
        else:
            gen = rightGen
    elif rightHeldTargetObjNow or (leftHeldNow and not leftHeldTargetObjNow):
        # Try right hand first if we're holding something else in the left or the target in the right.
        gen = roundrobin(rightGen, leftGen)
    elif leftHeldTargetObjNow or (rightHeldNow and not rightHeldTargetObjNow):
        # Try left hand first if we're holding something else in the right or the target in the left
        gen = roundrobin(leftGen, rightGen)
    else:
        # Just prefer right hand
        gen = roundrobin(rightGen, leftGen)

    return gen

def minimalConf(conf, hand):
    if hand == 'left':
        return (tuple(conf['pr2Base']), tuple(conf['pr2LeftArm']))
    else:
        return (tuple(conf['pr2Base']), tuple(conf['pr2RightArm']))

################
## Drawing
################
    
def drawPoseConf(pbs, placeB, conf, confAppr, prob, win, color = None):
    ws = pbs.getShadowWorld(prob)
    ws.world.getObjectShapeAtOrigin(placeB.obj).applyLoc(placeB.objFrame()).draw(win, color=color)
    conf.draw(win, color=color)

def drawObjAndShadow(pbs, placeB, prob, win, color = None):
    # Draw the object in its native color, but use the argument for the shadow
    ws = pbs.getShadowWorld(prob)
    obj = placeB.obj
    ws.world.getObjectShapeAtOrigin(obj).applyLoc(placeB.objFrame()).draw(win)
    if shadowName(obj) in ws.world.objects:
        ws.world.getObjectShapeAtOrigin(shadowName(obj)).applyLoc(placeB.objFrame()).draw(win, color=color)

def sameBase(pbs):
    # base is None or (fixed, base)
    return pbs.base and pbs.base[0]     # fixed base
