import pdb
import numpy as np
import math
import random
import hu
import time
import copy
import windowManager3D as wm
import shapes
import planGlobals as glob
from planGlobals import torsoZ, traceGen
from traceFile import debugMsg, debug
from miscUtil import argmax, isGround, isVar, argmax, squashOne
from dist import UniformDist, DDist
from geom import bboxCenter
from pr2Robot import CartConf, gripperFaceFrame, pr2BaseLink
from planUtil import PoseD, ObjGraspB, ObjPlaceB, Violations
from pr2Util import shadowName, objectName, Memoizer, inside, otherHand, bboxMixedCoords, bboxRandomCoords, shadowWidths, supportFaceIndex
import fbch
from fbch import getMatchingFluents
from belief import Bd, B
from pr2Fluents import CanReachHome, canReachHome, In, Pose, CanPickPlace, \
    BaseConf, Holding, CanReachNB, Conf, CanPush, canPush, pushGraspB, permanent
from transformations import rotation_matrix
from cspace import xyCI, CI, xyCOParts
from pr2Visible import visible, lookAtConf, viewCone, findSupportTableInPbs
from pr2RRT import planRobotGoalPath, interpolatePath
from traceFile import tr
from miscUtil import roundrobin

Ident = hu.Transform(np.eye(4))            # identity transform
tiny = 1.0e-6

################
# Basic tests for pick and place
################

def legalGrasp(pbs, conf, hand, objGrasp, objPlace):
    deltaThreshold = (0.01, 0.01, 0.01, 0.02)
    # !! This should check for kinematic feasibility over a range of poses.
    of = objectGraspFrame(pbs, objGrasp, objPlace, hand)
    rf = robotGraspFrame(pbs, conf, hand)
    result = of.withinDelta(rf, deltaThreshold)
    return result

def objectGraspFrame(pbs, objGrasp, objPlace, hand):
    # Find the robot wrist frame corresponding to the grasp at the placement
    objFrame = objPlace.objFrame()
    graspDesc = objGrasp.graspDesc[objGrasp.grasp.mode()]
    faceFrame = graspDesc.frame.compose(objGrasp.poseD.mode())
    centerFrame = faceFrame.compose(hu.Pose(0,0,graspDesc.dz,0))
    graspFrame = objFrame.compose(centerFrame)
    # !! Rotates wrist frame to grasp face frame - defined in pr2Robot
    gT = gripperFaceFrame[hand]
    wristFrame = graspFrame.compose(gT.inverse())
    # assert wristFrame.pose()

    if debug('objectGraspFrame'):
        print 'objGrasp', objGrasp
        print 'objPlace', objPlace
        print 'objFrame\n', objFrame.matrix
        print 'grasp faceFrame\n', faceFrame.matrix
        print 'centerFrame\n', centerFrame.matrix
        print 'graspFrame\n', graspFrame.matrix
        print 'object wristFrame\n', wristFrame.matrix

    return wristFrame

def robotGraspFrame(pbs, conf, hand):
    robot = pbs.getRobot()
    _, frames = robot.placement(conf, getShapes=[])
    wristFrame = frames[robot.wristFrameNames[hand]]
    if debug('robotGraspFrame'):
        print 'robot wristFrame\n', wristFrame
    return wristFrame

###################
# !! Need implementations of InPickApproach and InPlaceDeproach

def inPickApproach(*x): return True
def InPlaceDeproach(*x): return True

###################

# Pick conditions
# pick1. move home->pre with obj at pick pose
# pick2. move home->pick without obj
# pick3. move home->pick with obj in hand 

# Place conditions are equivalent
# place1. move home->pre with obj in hand
# place1. move home->place with hand empty
# place2. move home->pre with obj at place pose

################
## GENERATORS
################

# This needs generalization

approachConfCacheStats = [0,0]
def findApproachConf(pbs, obj, placeB, conf, hand, prob):
    approachConfCacheStats[0] += 1
    cached = pbs.getRoadMap().approachConfs.get(conf, False)
    if cached is not False:
        approachConfCacheStats[1] += 1
        return cached
    robot = pbs.getRobot()
    cart = conf.cartConf()
    wristFrame = cart[robot.armChainNames[hand]]
    if abs(wristFrame.matrix[2,0]) < 0.1: # horizontal
        offset = hu.Pose(-glob.approachBackoff,0.,glob.approachPerpBackoff,0.)
    else:                               # vertical
        offset = hu.Pose(-glob.approachBackoff,0.,0.,0.)
    wristFrameBack = wristFrame.compose(offset)
    cartBack = cart.set(robot.armChainNames[hand], wristFrameBack)
    confBack = robot.inverseKin(cartBack, conf = conf)
    if not None in confBack.values():
        pbs.getRoadMap().approachConfs[conf] = confBack
        return confBack
    else:
        pbs.getRoadMap().approachConfs[conf] = None
        return None

# Our choices are (generated by graspGen):
# 1. The grasp surface (graspDesc)
# !! 2. The pose on the grasp surface (3 params) -- for now -- skip this
# 3. The conf of the robot (and an approach conf, but we won't vary that)
def graspGen(pbs, graspB, placeB=None, conf=None, hand=None, prob=None):
    obj = graspB.obj
    grasps = list(graspB.grasp.support())
    random.shuffle(grasps)
    for grasp in grasps:
        if debug('graspGen'):
            print 'graspGen: Generating grasp=', grasp
        # TODO: Should also sample a pose in the grasp face...
        gB = ObjGraspB(graspB.obj, graspB.graspDesc, grasp, None,
                       # !! Need to pick offset for grasp to be feasible
                       PoseD(graspB.poseD.mode() or hu.Pose(0.0, -0.025, 0.0, 0.0),
                             graspB.poseD.var),
                       delta=graspB.delta)
        yield gB

def potentialLookConfGen(pbs, prob, shape, maxDist):
    def testPoseInv(basePoseInv):
        bb = shape.applyTrans(basePoseInv).bbox()
        return bb[0][0] > 0 and bb[1][0] > 0

    centerPoint = hu.Point(np.resize(np.hstack([bboxCenter(shape.bbox()), [1]]), (4,1)))
    tested = set([])
    rm = pbs.getRoadMap()
    for node in rm.nodes():             # !!
        nodeBase = tuple(node.conf['pr2Base'])
        if nodeBase in tested:
            continue
        else:
            tested.add(nodeBase)
        x,y,th = nodeBase
        basePose = hu.Pose(x,y,0,th)
        dist = centerPoint.distanceXY(basePose.point())
        if dist > maxDist:
            continue
        inv = basePose.inverse()
        if not testPoseInv(inv):
            # Rotate the base to face the center of the object
            center = inv.applyToPoint(centerPoint)
            angle = math.atan2(center.matrix[0,0], center.matrix[1,0])
            rotBasePose = basePose.compose(hu.Pose(0,0,0,-angle))
            par = rotBasePose.pose().xyztTuple()
            rotConf = node.conf.set('pr2Base', (par[0], par[1], par[3]))
            if debug('potentialLookConfs'):
                print 'basePose', node.conf['pr2Base']
                print 'center', center
                print 'rotBasePose', rotConf['pr2Base']
            if testPoseInv(rotBasePose.inverse()):
                if rm.confViolations(rotConf, pbs, prob):
                    yield rotConf
        else:
            if debug('potentialLookConfs'):
                node.conf.draw('W')
                print 'node.conf', node.conf['pr2Base']
                raw_input('potential look conf')
            if rm.confViolations(node.conf, pbs, prob):
                yield node.conf
    return

ang = -math.pi/2
rotL = hu.Transform(rotation_matrix(-math.pi/4, (1,0,0)))
def trL(p): return p.compose(rotL)
rotR = hu.Transform(rotation_matrix(math.pi/4, (1,0,0)))
def trR(p): return p.compose(rotR)
lookPoses = {'left': [trL(x) for x in [hu.Pose(0.4, 0.35, 1.0, ang),
                                       hu.Pose(0.4, 0.25, 1.0, ang),
                                       hu.Pose(0.5, 0.08, 1.0, ang),
                                       hu.Pose(0.5, 0.18, 1.0, ang)]],
             'right': [trR(x) for x in [hu.Pose(0.4, -0.35, 0.9, -ang),
                                        hu.Pose(0.4, -0.25, 0.9, -ang),
                                        hu.Pose(0.5, -0.08, 1.0, -ang),
                                        hu.Pose(0.5, -0.18, 1.0, -ang)]]}
def potentialLookHandConfGen(pbs, prob, hand):
    shWorld = pbs.getShadowWorld(prob)
    robot = pbs.getConf().robot
    curCartConf = pbs.getConf().cartConf()
    chain = robot.armChainNames[hand]
    baseFrame = curCartConf['pr2Base']
    for pose in lookPoses[hand]:
        if debug('potentialLookHandConfs'):
            print 'potentialLookHandConfs trying:\n', pose
        target = baseFrame.compose(pose)
        cartConf = curCartConf.set(chain, target)
        conf = robot.inverseKin(cartConf, conf=pbs.getConf())
        if all(v for v in conf.conf.values()):
            if debug('potentialLookHandConfs'):
                conf.draw('W', 'blue')
                print 'lookPose\n', pose.matrix
                print 'target\n', target.matrix
                print 'conf', conf.conf
                print 'cart\n', cartConf[chain].matrix
                raw_input('potentialLookHandConfs')
            yield conf
    return

################
## Drawing
################
    
def drawPoseConf(pbs, placeB, conf, confAppr, prob, win, color = None):
    ws = pbs.getShadowWorld(prob)
    ws.world.getObjectShapeAtOrigin(placeB.obj).applyLoc(placeB.objFrame()).draw(win, color=color)
    conf.draw(win, color=color)

def drawObjAndShadow(pbs, placeB, prob, win, color = None):
    # Draw the object in its native color, but use the argument for the shadow
    ws = pbs.getShadowWorld(prob)
    obj = placeB.obj
    ws.world.getObjectShapeAtOrigin(obj).applyLoc(placeB.objFrame()).draw(win)
    if shadowName(obj) in ws.world.objects:
        ws.world.getObjectShapeAtOrigin(shadowName(obj)).applyLoc(placeB.objFrame()).draw(win, color=color)

def sameBase(pbs):
    # base is None or (fixed, base)
    return pbs.base and pbs.base[0]     # fixed base


# Returns (hand, obj) for Holding fluents.   Leave it out if obj is 'none'
def getHolding(goalConds):
    pfbs = fbch.getMatchingFluents(goalConds,
                                   Bd([Holding(['Hand']), 'Obj', 'P'], True))
    held = []
    for (pf, pb) in pfbs:
        if isGround(pb.values()):
            if pb['Obj'] != 'none':
                held.append((pb['Hand'], pb['Obj']))
    return held

# find bbox for CI_1(2), that is, displacements of bb1 that place it
# inside bb2.  Assumes that bb1 has origin at 0,0.
def bboxInterior(bb1, bb2):
    for j in xrange(3):
        di1 = bb1[1,j] - bb1[0,j]
        di2 = bb2[1,j] - bb2[0,j]
        if di1 > di2: return None
    return np.array([[bb2[i,j] - bb1[i,j] for j in range(3)] for i in range(2)])

# TODO: Should pick relevant orientations... or more samples.
angleList = [-math.pi/2. -math.pi/4., 0.0, math.pi/4, math.pi/2]

# (regShapeName, obj, hand, grasp) : (n_attempts, [relPose, ...])
regionPoseCache = {}

def potentialRegionPoseGen(pbs, obj, placeB, graspB, prob, regShapes, hand, base,
                           maxPoses = 30):
    def interpolateVars(maxV, minV, n):
        deltaV = [(maxV[i]-minV[i])/(n-1.) for i in range(4)]
        if all([d < 0.001 for d in deltaV]):
            return [maxV]
        Vs = []
        for j in range(n):
            Vs.append(tuple([maxV[i]-j*deltaV[i] for i in range(4)]))
        return Vs

    if traceGen:
        print ' **', 'potentialRegionPoseGen', placeB.poseD.mode(), graspB.grasp.mode(), hand

    maxVar = placeB.poseD.var
    minVar = pbs.domainProbs.obsVarTuple
    count = 0
    # Preferentially use large variance...
    for medVar in interpolateVars(maxVar, minVar, 4):
        if debug('potentialRegionPoseGen'):
            print 'potentialRegionPoseGen var', medVar
        pB = placeB.modifyPoseD(var=medVar)
        for pose in potentialRegionPoseGenAux(pbs, obj, pB, graspB, prob, regShapes,
                                              hand, base, maxPoses):
            yield pose
            if count > maxPoses: return
            count += 1

def potentialRegionPoseGenAux(pbs, obj, placeB, graspB, prob, regShapes, hand, base,
                              maxPoses = 30):
    def genPose(rs, angle, point):
        (x,y,z,_) = point
        # Support pose, we assume that sh is on support face
        pose = hu.Pose(x,y,z, 0.)     # shRotations is already rotated
        sh = shRotations[angle].applyTrans(pose)
        if debug('potentialRegionPoseGen'):
            pbs.draw(prob, 'W'); sh.draw('W', 'orange')
            print x,y,z,angle
            raw_input('Go?')
        pose = hu.Pose(x,y,z,angle)
        if inside(sh, rs, strict=True) and \
           all(not sh.collides(obst) for (ig, obst) in reachObsts if obj not in ig):
            debugMsg('potentialRegionPoseGen', ('-> pose', pose))
            return pose
        else:
            debugMsg('potentialRegionPoseGen', ('fail pose', pose))
            pbs.draw(prob, 'W'); sh.draw('W', 'orange'); rs.draw('W', 'purple')

    def poseViolationWeight(pose):
        tag = 'potentialRegionPoseGenWeight'
        pB = placeB.modifyPoseD(mu=pose)
        for gB in graspGen(pbs, graspB):
            grasp = gB.grasp.mode()
            debugMsg(tag, 'Trying grasp = %d'%grasp)
            if base:
                c, ca, v = next(potentialGraspConfGen(pbs, pB, gB, None, hand, base, prob, nMax=1),
                                (None,None,None))
            else:
                # Try not to move the base...
                cb = pbs.getConf()['pr2Base']
                c, ca, v = next(potentialGraspConfGen(pbs, pB, gB, None, hand, cb, prob, nMax=1),
                                (None,None,None))
                if not v:
                    c, ca, v = next(potentialGraspConfGen(pbs, pB, gB, None, hand, None, prob, nMax=1),
                                    (None,None,None))
            if v:
                if debug(tag):
                    pbs.draw(prob, 'W'); c.draw('W', 'green')
                    debugMsg(tag, 'v=%s'%v, 'weight=%s'%str(v.weight()),
                             'pose=%s'%pose, 'grasp=%s'%grasp)
                
                return v.weight() + baseDist(pbs.getConf(), ca)

            else:
                if debug(tag):
                    debugMsg(tag, 'v=%s'%v, 'pose=%s'%pose, 'grasp=%s'%grasp)
        return None

    if traceGen:
        print ' **', 'potentialRegionPoseGenAux', placeB.poseD.mode(), graspB.grasp.mode(), hand

    tag = 'potentialRegionPoseGen'
    debugMsg(tag, placeB, shadowWidths(placeB.poseD.var, placeB.delta, prob))

    if debug(tag):
        pbs.draw(prob, 'W')
        for rs in regShapes: rs.draw('W', 'purple')

    ff = placeB.faceFrames[placeB.support.mode()]
    shWorld = pbs.getShadowWorld(prob)
    
    objShadow = pbs.objShadow(obj, shadowName(obj), prob, placeB, ff)
    if placeB.poseD.mode():
        tr(tag, 'pose specified', placeB.poseD.mode(), ol = True)
        sh = objShadow.applyLoc(placeB.objFrame()).prim()
        verts = sh.vertices()
        if any(inside(sh, rs, strict=True) for rs in regShapes)  and \
           all(not sh.collides(obst) for (ig, obst) in reachObsts if obj not in ig):
            tr(tag, 'pose specified and safely in region',
               placeB.poseD.mode(), ol = True)
            yield placeB.poseD.mode()
        else:
            tr(tag, 'pose specified and not safely in region')

    if not base:
        # cacheResults = []
        cacheResults = checkRegionPoseCache(obj, graspB.grasp.mode(), regShapes, hand)
        if cacheResults is None:
            tr(tag, 'Losing proposition')
            return
        else:
            for pose in cacheResults:
                cost = poseViolationWeight(pose)
                if debug(tag) and cost is not None:
                        print 'Cached ->', pose, 'cost=', cost
                yield pose

    shRotations = dict([(angle, objShadow.applyTrans(hu.Pose(0,0,0,angle)).prim()) \
                        for angle in angleList])
    hyps, points = regionPoseHyps(pbs, prob, regShapes, shRotations, maxPoses)

    if hyps:
        hyps = sorted(hyps)
        # Randomize by regions
        levels = []
        values = []
        for p in hyps:
            (c, r, i) = p
            if not values or values[-1] != c:
                values.append(c)
                levels.append([p])
            else:
                levels[-1].append(p)
        for l in levels:
            random.shuffle(l)
        pointDist = []
        for l in levels: pointDist.extend(l)
        debugMsg(tag, 'Invalid points in blue, len(valid)=%d'%len(pointDist))
    else:
        debugMsg(tag, 'Invalid points in blue, no valid points in region')
        return
    maxTries = min(2*maxPoses, len(pointDist))
    count = 0
    graspMode = graspB.grasp.mode()

    def poseCost(tries):
        hcost, rs, index = pointDist[tries]
        if glob.useRegionPoseCache and not base:
            key = (rs.name(), obj, hand, graspMode)
            entry = regionPoseCache[key]
            entry[0] += 1
        angle, point = points[index]
        p = genPose(rs, angle, point)
        if not p: return None
        cost = poseViolationWeight(p)
        if glob.useRegionPoseCache and not base and cost is not None:
            entry[1].append(rs.origin().inverse().compose(p).pose())
        return (p, rs, cost)

    for pose, cost in leastCostGen(poseCost, maxPoses, maxTries):
        count += 1
        if debug(tag):
            print '->', pose, 'cost=', cost
            # shRotations is already rotated
            (x,y,z,angle) = pose.xyztTuple()
            shRotations[angle].applyTrans(hu.Pose(x,y,z, 0.)).draw('W', 'green')
        yield pose
    if True: # debug(tag):
        print 'Tried', maxTries, 'with', hand, 'returned', count, 'for regions', [r.name() for r in regShapes]
        pdb.set_trace()
    return

maxRegionPoseAttempts = 100
def checkRegionPoseCache(obj, graspMode, regShapes, hand):
    if not glob.useRegionPoseCache: return []
    ans = None
    for rs in regShapes:
        key = (rs.name(), obj, hand, graspMode)
        if key in regionPoseCache:
            (tried, poses) = regionPoseCache[key]
            if not poses:
                if tried > maxRegionPoseAttempts:
                    print 'Giving up on', key
                    continue
                ans = []      # if any subregion has not failed, then don't fail.
            else:
                # return []
                origin = rs.origin()
                # convert relative poses to global poses
                poses = [origin.compose(p).pose() for p in poses]
                random.shuffle(poses)
                if debug('potentialRegionPoseGen'):
                    print '... Found', len(poses), 'poses in cache for', hand
                return poses
        else:
            regionPoseCache[key] = list((0., list()))
            ans = []
    return ans

def regionPoseHyps(pbs, prob, regShapes, shRotations, maxPoses):
    tag = 'regionPoseHyps'
    clearance = 0.01
    obstCost = 10.
    hyps = []                         # (index, cost)
    points = []                       # [(angle, xyz1)]
    count = 0
    shWorld = pbs.getShadowWorld(prob)
    for rs in regShapes:
        tr(tag, rs.name(), ol = True)
        if debug(tag):
            print 'Considering region', rs.name()
        for (angle, shRot) in shRotations.items():
            bI = CI(shRot, rs.prim())
            if bI is None:
                if debug(tag):
                    print 'bI is None for angle', angle
                    raw_input('bI')
                continue
            elif debug(tag):
                bI.draw('W', 'cyan')
                debugMsg(tag, 'Region interior in cyan for angle', angle)
            coFixed = squashOne([xyCOParts(shRot, o) for o in shWorld.getObjectShapes() \
                                 if o.name() in shWorld.fixedObjects])
            coObst = squashOne([xyCOParts(shRot, o) for o in shWorld.getNonShadowShapes() \
                                if o.name() not in shWorld.fixedObjects])
            coShadow = squashOne([xyCOParts(shRot, o) for o in shWorld.getShadowShapes() \
                                  if o.name() not in shWorld.fixedObjects])
            if debug(tag):
                for co in coFixed: co.draw('W', 'red')
                for co in coObst: co.draw('W', 'brown')
                for co in coShadow: co.draw('W', 'orange')
            z0 = bI.bbox()[0,2] + clearance
            # for point in bboxGridCoords(bI.bbox(), res = 0.01, z=z0):
            # for point in bboxRandomCoords(bI.bbox(), n=maxPoses, z=z0):
            # p = 0.x chance of generating a grid point.
            icount = 0
            nc = (maxPoses/len(shRotations.keys()))
            # for point in bboxMixedCoords(bI.bbox(), 0.5, n=maxPoses, z=z0):
            for point in bboxRandomCoords(bI.bbox(), n=maxPoses, z=z0):
                pt = point.reshape(4,1)
                if any(np.all(np.dot(co.planes(), pt) <= tiny) for co in coFixed):
                    if debug(tag):
                        shapes.pointBox(pt.T[0]).draw('W', 'blue')
                    continue
                cost = 0
                for co in coObst:
                    if np.all(np.dot(co.planes(), pt) <= tiny): cost += obstCost
                for co in coShadow:
                    if np.all(np.dot(co.planes(), pt) <= tiny): cost += 0.5*obstCost
                points.append((angle, point.tolist()))
                hyp = (cost, rs, count)
                hyps.append(hyp)
                count += 1
                icount += 1
                if icount > nc: break
    return hyps, points

def leastCostGen(candidateScoreFn, maxCount, maxTries):
    costHistory = []
    poseHistory = []
    historySize = 10                # used to be 5 or 20
    tries = 0
    count = 0
    while count < maxCount and tries < maxTries:
        score = candidateScoreFn(tries)
        tries += 1
        if not score: continue
        pose, rs, cost = score
        if cost is None: continue
        if len(costHistory) < historySize:
            costHistory.append(cost)
            poseHistory.append(pose)
            continue
        elif cost > min(costHistory):
            minIndex = costHistory.index(min(costHistory))
            pose = poseHistory[minIndex]
            poseCost = costHistory[minIndex]
            costHistory[minIndex] = cost
            poseHistory[minIndex] = pose
        else:                           # cost <= min(costHistory)
            poseCost = cost
        count += 1
        yield pose, poseCost

def baseDist(c1, c2):
    (x1,y1,th1) = c1['pr2Base']
    (x2,y2,th2) = c2['pr2Base']
    return ((x2-x1)**2 + (y2-y1)**2 + hu.angleDiff(th1,th2)**2)**0.5
    
#############

def confDelta(c1, c2):
    return max([max([abs(x-y) for (x,y) in zip(c1.conf[k], c2.conf[k])]) \
                for k in c1 if k in c2])

def findGraspConfEntries(conf):
    return [(c, ca, pbs, prob, viol) \
            for (c, ca, pbs, prob, viol) in graspConfs \
            if confDelta(c, conf) < 0.001 or confDelta(ca, conf) < 0.001]


def chooseHandGen(pbs, goalConds, obj, hand, leftGen, rightGen):
    tag = 'chooseHandGen'
    assert not (pbs.useRight == False and hand == 'right')
    mustUseLeft = (hand == 'left' or not pbs.useRight)
    mustUseRight = (hand == 'right')
    holding = dict(getHolding(goalConds))   # values might be 'none'
    # What are we required to be holding
    leftHeldInGoal = 'left' in holding
    rightHeldInGoal = 'right' in holding
    # What are we currently holding (heuristic value)
    leftHeldNow = pbs.getHeld('left') != 'none'
    rightHeldNow = pbs.getHeld('right') != 'none'
    # Are we already holding the desired object
    leftHeldTargetObjNow = pbs.getHeld('left') == obj
    rightHeldTargetObjNow = pbs.getHeld('right') == obj

    if leftHeldInGoal and rightHeldInGoal:
        # Both hands are busy!!
        return []

    if mustUseLeft or rightHeldInGoal:
        if leftHeldInGoal:
            tr(tag, 0, '=> Left held already in goal, fail')
            return []
        else:
            gen = leftGen
    elif mustUseRight or leftHeldInGoal:
        if rightHeldInGoal:
            tr(tag, 0, '=> Right held already in goal, fail')
            return []
        else:
            gen = rightGen
    elif rightHeldTargetObjNow or (leftHeldNow and not leftHeldTargetObjNow):
        # Try right hand first if we're holding something in the left
        gen = roundrobin(rightGen, leftGen)
    elif leftHeldTargetObjNow or (rightHeldNow and not rightHeldTargetObjNow):
        # Try right hand first if we're holding something in the left
        gen = roundrobin(leftGen, rightGen)
    else:
        gen = roundrobin(rightGen, leftGen)
    return gen

def minimalConf(conf, hand):
    if hand == 'left':
        return (tuple(conf['pr2Base']), tuple(conf['pr2LeftArm']))
    else:
        return (tuple(conf['pr2Base']), tuple(conf['pr2RightArm']))

###### Helpers for XinGen

def getRegions(region):
    if not isinstance(region, (list, tuple, frozenset)):
        return frozenset([region])
    elif len(region) == 0:
        raise Exception, 'need a region to place into'
    else:
        return frozenset(region)

def getPoseAndSupport(tag, obj, pbs, prob):
    # Set pose and support from current state
    pose = None
    if pbs.getPlaceB(obj, default=False):
        # If it is currently placed, use that support
        support = pbs.getPlaceB(obj).support.mode()
        pose = pbs.getPlaceB(obj).poseD.mode()
        tr(tag, 'Using current placeB, support=%s, pose=%s'%(sup, pose.xyztTuple()))
    elif obj == pbs.getHeld('left'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'left')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('left', suport))
    elif obj == pbs.getHeld('right'):
        attachedShape = pbs.getRobot().attachedObj(pbs.getShadowWorld(prob),
                                                   'right')
        shape = pbs.getObjectShapeAtOrigin(obj).\
                applyLoc(attachedShape.origin())
        support = supportFaceIndex(shape)
        tr(tag, 'Object already in %s hand, support=%s'%('right', suport))
    else:
        raise Exception('Cannot determine support')
    return pose, support
